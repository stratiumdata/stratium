// @generated by protoc-gen-es v1.10.1 with parameter "target=ts"
// @generated from file models/ztdf.proto (syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Struct } from "@bufbuild/protobuf";

/**
 * @generated from enum AppliesTo
 */
export enum AppliesTo {
  /**
   * @generated from enum value: CIPHERTEXT = 0;
   */
  CIPHERTEXT = 0,

  /**
   * @generated from enum value: PLAINTEXT = 1;
   */
  PLAINTEXT = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(AppliesTo)
proto3.util.setEnumType(AppliesTo, "AppliesTo", [
  { no: 0, name: "CIPHERTEXT" },
  { no: 1, name: "PLAINTEXT" },
]);

/**
 * @generated from message Assertion
 */
export class Assertion extends Message<Assertion> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: Assertion.AssertionType type = 2;
   */
  type = Assertion_AssertionType.HANDLING;

  /**
   * @generated from field: Assertion.AssertionScope scope = 3;
   */
  scope = Assertion_AssertionScope.PAYLOAD;

  /**
   * @generated from field: AppliesTo applies_to_state = 4;
   */
  appliesToState = AppliesTo.CIPHERTEXT;

  /**
   * @generated from field: Assertion.Statement statement = 5;
   */
  statement?: Assertion_Statement;

  /**
   * @generated from field: Assertion.AssertionBinding binding = 6;
   */
  binding?: Assertion_AssertionBinding;

  constructor(data?: PartialMessage<Assertion>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Assertion";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(Assertion_AssertionType) },
    { no: 3, name: "scope", kind: "enum", T: proto3.getEnumType(Assertion_AssertionScope) },
    { no: 4, name: "applies_to_state", kind: "enum", T: proto3.getEnumType(AppliesTo) },
    { no: 5, name: "statement", kind: "message", T: Assertion_Statement },
    { no: 6, name: "binding", kind: "message", T: Assertion_AssertionBinding },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Assertion {
    return new Assertion().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Assertion {
    return new Assertion().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Assertion {
    return new Assertion().fromJsonString(jsonString, options);
  }

  static equals(a: Assertion | PlainMessage<Assertion> | undefined, b: Assertion | PlainMessage<Assertion> | undefined): boolean {
    return proto3.util.equals(Assertion, a, b);
  }
}

/**
 * @generated from enum Assertion.AssertionScope
 */
export enum Assertion_AssertionScope {
  /**
   * @generated from enum value: PAYLOAD = 0;
   */
  PAYLOAD = 0,

  /**
   * @generated from enum value: TDO = 1;
   */
  TDO = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(Assertion_AssertionScope)
proto3.util.setEnumType(Assertion_AssertionScope, "Assertion.AssertionScope", [
  { no: 0, name: "PAYLOAD" },
  { no: 1, name: "TDO" },
]);

/**
 * @generated from enum Assertion.AssertionType
 */
export enum Assertion_AssertionType {
  /**
   * @generated from enum value: HANDLING = 0;
   */
  HANDLING = 0,

  /**
   * @generated from enum value: OTHER = 1;
   */
  OTHER = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(Assertion_AssertionType)
proto3.util.setEnumType(Assertion_AssertionType, "Assertion.AssertionType", [
  { no: 0, name: "HANDLING" },
  { no: 1, name: "OTHER" },
]);

/**
 * @generated from message Assertion.Statement
 */
export class Assertion_Statement extends Message<Assertion_Statement> {
  /**
   * @generated from field: Assertion.Statement.StatementFormat format = 1;
   */
  format = Assertion_Statement_StatementFormat.JSON_STRUCTURED;

  /**
   * @generated from field: string schema = 2;
   */
  schema = "";

  /**
   * @generated from field: google.protobuf.Struct value = 3;
   */
  value?: Struct;

  /**
   * @generated from field: string jsonValue = 4;
   */
  jsonValue = "";

  constructor(data?: PartialMessage<Assertion_Statement>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Assertion.Statement";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "format", kind: "enum", T: proto3.getEnumType(Assertion_Statement_StatementFormat) },
    { no: 2, name: "schema", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "value", kind: "message", T: Struct },
    { no: 4, name: "jsonValue", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Assertion_Statement {
    return new Assertion_Statement().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Assertion_Statement {
    return new Assertion_Statement().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Assertion_Statement {
    return new Assertion_Statement().fromJsonString(jsonString, options);
  }

  static equals(a: Assertion_Statement | PlainMessage<Assertion_Statement> | undefined, b: Assertion_Statement | PlainMessage<Assertion_Statement> | undefined): boolean {
    return proto3.util.equals(Assertion_Statement, a, b);
  }
}

/**
 * @generated from enum Assertion.Statement.StatementFormat
 */
export enum Assertion_Statement_StatementFormat {
  /**
   * @generated from enum value: JSON_STRUCTURED = 0;
   */
  JSON_STRUCTURED = 0,

  /**
   * @generated from enum value: XML_STRUCTURED = 1;
   */
  XML_STRUCTURED = 1,

  /**
   * @generated from enum value: BASE_64_BINARY = 2;
   */
  BASE_64_BINARY = 2,

  /**
   * @generated from enum value: STRING = 3;
   */
  STRING = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(Assertion_Statement_StatementFormat)
proto3.util.setEnumType(Assertion_Statement_StatementFormat, "Assertion.Statement.StatementFormat", [
  { no: 0, name: "JSON_STRUCTURED" },
  { no: 1, name: "XML_STRUCTURED" },
  { no: 2, name: "BASE_64_BINARY" },
  { no: 3, name: "STRING" },
]);

/**
 * @generated from message Assertion.AssertionBinding
 */
export class Assertion_AssertionBinding extends Message<Assertion_AssertionBinding> {
  /**
   * @generated from field: string method = 1;
   */
  method = "";

  /**
   * @generated from field: string signature = 2;
   */
  signature = "";

  constructor(data?: PartialMessage<Assertion_AssertionBinding>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Assertion.AssertionBinding";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "method", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "signature", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Assertion_AssertionBinding {
    return new Assertion_AssertionBinding().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Assertion_AssertionBinding {
    return new Assertion_AssertionBinding().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Assertion_AssertionBinding {
    return new Assertion_AssertionBinding().fromJsonString(jsonString, options);
  }

  static equals(a: Assertion_AssertionBinding | PlainMessage<Assertion_AssertionBinding> | undefined, b: Assertion_AssertionBinding | PlainMessage<Assertion_AssertionBinding> | undefined): boolean {
    return proto3.util.equals(Assertion_AssertionBinding, a, b);
  }
}

/**
 * @generated from message EncryptionInformation
 */
export class EncryptionInformation extends Message<EncryptionInformation> {
  /**
   * @generated from field: EncryptionInformation.EncryptionInformationType type = 1;
   */
  type = EncryptionInformation_EncryptionInformationType.SPLIT;

  /**
   * @generated from field: repeated EncryptionInformation.KeyAccessObject key_access = 2;
   */
  keyAccess: EncryptionInformation_KeyAccessObject[] = [];

  /**
   * @generated from field: EncryptionInformation.Method method = 3;
   */
  method?: EncryptionInformation_Method;

  /**
   * @generated from field: EncryptionInformation.IntegrityInformation integrity_information = 4;
   */
  integrityInformation?: EncryptionInformation_IntegrityInformation;

  /**
   * @generated from field: string policy = 5;
   */
  policy = "";

  constructor(data?: PartialMessage<EncryptionInformation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "EncryptionInformation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(EncryptionInformation_EncryptionInformationType) },
    { no: 2, name: "key_access", kind: "message", T: EncryptionInformation_KeyAccessObject, repeated: true },
    { no: 3, name: "method", kind: "message", T: EncryptionInformation_Method },
    { no: 4, name: "integrity_information", kind: "message", T: EncryptionInformation_IntegrityInformation },
    { no: 5, name: "policy", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EncryptionInformation {
    return new EncryptionInformation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EncryptionInformation {
    return new EncryptionInformation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EncryptionInformation {
    return new EncryptionInformation().fromJsonString(jsonString, options);
  }

  static equals(a: EncryptionInformation | PlainMessage<EncryptionInformation> | undefined, b: EncryptionInformation | PlainMessage<EncryptionInformation> | undefined): boolean {
    return proto3.util.equals(EncryptionInformation, a, b);
  }
}

/**
 * @generated from enum EncryptionInformation.EncryptionInformationType
 */
export enum EncryptionInformation_EncryptionInformationType {
  /**
   * @generated from enum value: SPLIT = 0;
   */
  SPLIT = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(EncryptionInformation_EncryptionInformationType)
proto3.util.setEnumType(EncryptionInformation_EncryptionInformationType, "EncryptionInformation.EncryptionInformationType", [
  { no: 0, name: "SPLIT" },
]);

/**
 * @generated from message EncryptionInformation.KeyAccessObject
 */
export class EncryptionInformation_KeyAccessObject extends Message<EncryptionInformation_KeyAccessObject> {
  /**
   * @generated from field: EncryptionInformation.KeyAccessObject.KeyAccessObjectType type = 1;
   */
  type = EncryptionInformation_KeyAccessObject_KeyAccessObjectType.WRAPPED;

  /**
   * @generated from field: string url = 2;
   */
  url = "";

  /**
   * @generated from field: EncryptionInformation.KeyAccessObject.KeyAccessObjectProtocol protocol = 3;
   */
  protocol = EncryptionInformation_KeyAccessObject_KeyAccessObjectProtocol.KAS;

  /**
   * @generated from field: string wrapped_key = 4;
   */
  wrappedKey = "";

  /**
   * @generated from field: string sid = 5;
   */
  sid = "";

  /**
   * @generated from field: string kid = 6;
   */
  kid = "";

  /**
   * @generated from field: EncryptionInformation.KeyAccessObject.PolicyBinding policy_binding = 7;
   */
  policyBinding?: EncryptionInformation_KeyAccessObject_PolicyBinding;

  /**
   * @generated from field: string encrypted_metadata = 8;
   */
  encryptedMetadata = "";

  /**
   * @generated from field: string tdf_spec_version = 9;
   */
  tdfSpecVersion = "";

  constructor(data?: PartialMessage<EncryptionInformation_KeyAccessObject>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "EncryptionInformation.KeyAccessObject";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(EncryptionInformation_KeyAccessObject_KeyAccessObjectType) },
    { no: 2, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "protocol", kind: "enum", T: proto3.getEnumType(EncryptionInformation_KeyAccessObject_KeyAccessObjectProtocol) },
    { no: 4, name: "wrapped_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "sid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "kid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "policy_binding", kind: "message", T: EncryptionInformation_KeyAccessObject_PolicyBinding },
    { no: 8, name: "encrypted_metadata", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "tdf_spec_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EncryptionInformation_KeyAccessObject {
    return new EncryptionInformation_KeyAccessObject().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EncryptionInformation_KeyAccessObject {
    return new EncryptionInformation_KeyAccessObject().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EncryptionInformation_KeyAccessObject {
    return new EncryptionInformation_KeyAccessObject().fromJsonString(jsonString, options);
  }

  static equals(a: EncryptionInformation_KeyAccessObject | PlainMessage<EncryptionInformation_KeyAccessObject> | undefined, b: EncryptionInformation_KeyAccessObject | PlainMessage<EncryptionInformation_KeyAccessObject> | undefined): boolean {
    return proto3.util.equals(EncryptionInformation_KeyAccessObject, a, b);
  }
}

/**
 * @generated from enum EncryptionInformation.KeyAccessObject.KeyAccessObjectType
 */
export enum EncryptionInformation_KeyAccessObject_KeyAccessObjectType {
  /**
   * @generated from enum value: WRAPPED = 0;
   */
  WRAPPED = 0,

  /**
   * @generated from enum value: REMOTE = 1;
   */
  REMOTE = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(EncryptionInformation_KeyAccessObject_KeyAccessObjectType)
proto3.util.setEnumType(EncryptionInformation_KeyAccessObject_KeyAccessObjectType, "EncryptionInformation.KeyAccessObject.KeyAccessObjectType", [
  { no: 0, name: "WRAPPED" },
  { no: 1, name: "REMOTE" },
]);

/**
 * @generated from enum EncryptionInformation.KeyAccessObject.KeyAccessObjectProtocol
 */
export enum EncryptionInformation_KeyAccessObject_KeyAccessObjectProtocol {
  /**
   * @generated from enum value: KAS = 0;
   */
  KAS = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(EncryptionInformation_KeyAccessObject_KeyAccessObjectProtocol)
proto3.util.setEnumType(EncryptionInformation_KeyAccessObject_KeyAccessObjectProtocol, "EncryptionInformation.KeyAccessObject.KeyAccessObjectProtocol", [
  { no: 0, name: "KAS" },
]);

/**
 * @generated from message EncryptionInformation.KeyAccessObject.PolicyBinding
 */
export class EncryptionInformation_KeyAccessObject_PolicyBinding extends Message<EncryptionInformation_KeyAccessObject_PolicyBinding> {
  /**
   * @generated from field: string alg = 1;
   */
  alg = "";

  /**
   * @generated from field: string hash = 2;
   */
  hash = "";

  constructor(data?: PartialMessage<EncryptionInformation_KeyAccessObject_PolicyBinding>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "EncryptionInformation.KeyAccessObject.PolicyBinding";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "alg", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EncryptionInformation_KeyAccessObject_PolicyBinding {
    return new EncryptionInformation_KeyAccessObject_PolicyBinding().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EncryptionInformation_KeyAccessObject_PolicyBinding {
    return new EncryptionInformation_KeyAccessObject_PolicyBinding().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EncryptionInformation_KeyAccessObject_PolicyBinding {
    return new EncryptionInformation_KeyAccessObject_PolicyBinding().fromJsonString(jsonString, options);
  }

  static equals(a: EncryptionInformation_KeyAccessObject_PolicyBinding | PlainMessage<EncryptionInformation_KeyAccessObject_PolicyBinding> | undefined, b: EncryptionInformation_KeyAccessObject_PolicyBinding | PlainMessage<EncryptionInformation_KeyAccessObject_PolicyBinding> | undefined): boolean {
    return proto3.util.equals(EncryptionInformation_KeyAccessObject_PolicyBinding, a, b);
  }
}

/**
 * @generated from message EncryptionInformation.Method
 */
export class EncryptionInformation_Method extends Message<EncryptionInformation_Method> {
  /**
   * @generated from field: string algorithm = 1;
   */
  algorithm = "";

  /**
   * @generated from field: bool is_streamable = 2;
   */
  isStreamable = false;

  /**
   * @generated from field: string iv = 3;
   */
  iv = "";

  constructor(data?: PartialMessage<EncryptionInformation_Method>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "EncryptionInformation.Method";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "algorithm", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "is_streamable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "iv", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EncryptionInformation_Method {
    return new EncryptionInformation_Method().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EncryptionInformation_Method {
    return new EncryptionInformation_Method().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EncryptionInformation_Method {
    return new EncryptionInformation_Method().fromJsonString(jsonString, options);
  }

  static equals(a: EncryptionInformation_Method | PlainMessage<EncryptionInformation_Method> | undefined, b: EncryptionInformation_Method | PlainMessage<EncryptionInformation_Method> | undefined): boolean {
    return proto3.util.equals(EncryptionInformation_Method, a, b);
  }
}

/**
 * @generated from message EncryptionInformation.IntegrityInformation
 */
export class EncryptionInformation_IntegrityInformation extends Message<EncryptionInformation_IntegrityInformation> {
  /**
   * @generated from field: EncryptionInformation.IntegrityInformation.RootSignature root_signature = 1;
   */
  rootSignature?: EncryptionInformation_IntegrityInformation_RootSignature;

  /**
   * @generated from field: string segment_hash_alg = 2;
   */
  segmentHashAlg = "";

  /**
   * @generated from field: repeated EncryptionInformation.IntegrityInformation.Segment segments = 3;
   */
  segments: EncryptionInformation_IntegrityInformation_Segment[] = [];

  /**
   * @generated from field: int32 segment_size_default = 4;
   */
  segmentSizeDefault = 0;

  /**
   * @generated from field: int32 encrypted_segment_size_default = 5;
   */
  encryptedSegmentSizeDefault = 0;

  constructor(data?: PartialMessage<EncryptionInformation_IntegrityInformation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "EncryptionInformation.IntegrityInformation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root_signature", kind: "message", T: EncryptionInformation_IntegrityInformation_RootSignature },
    { no: 2, name: "segment_hash_alg", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "segments", kind: "message", T: EncryptionInformation_IntegrityInformation_Segment, repeated: true },
    { no: 4, name: "segment_size_default", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "encrypted_segment_size_default", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EncryptionInformation_IntegrityInformation {
    return new EncryptionInformation_IntegrityInformation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EncryptionInformation_IntegrityInformation {
    return new EncryptionInformation_IntegrityInformation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EncryptionInformation_IntegrityInformation {
    return new EncryptionInformation_IntegrityInformation().fromJsonString(jsonString, options);
  }

  static equals(a: EncryptionInformation_IntegrityInformation | PlainMessage<EncryptionInformation_IntegrityInformation> | undefined, b: EncryptionInformation_IntegrityInformation | PlainMessage<EncryptionInformation_IntegrityInformation> | undefined): boolean {
    return proto3.util.equals(EncryptionInformation_IntegrityInformation, a, b);
  }
}

/**
 * @generated from message EncryptionInformation.IntegrityInformation.RootSignature
 */
export class EncryptionInformation_IntegrityInformation_RootSignature extends Message<EncryptionInformation_IntegrityInformation_RootSignature> {
  /**
   * @generated from field: string alg = 1;
   */
  alg = "";

  /**
   * @generated from field: string sig = 2;
   */
  sig = "";

  constructor(data?: PartialMessage<EncryptionInformation_IntegrityInformation_RootSignature>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "EncryptionInformation.IntegrityInformation.RootSignature";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "alg", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "sig", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EncryptionInformation_IntegrityInformation_RootSignature {
    return new EncryptionInformation_IntegrityInformation_RootSignature().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EncryptionInformation_IntegrityInformation_RootSignature {
    return new EncryptionInformation_IntegrityInformation_RootSignature().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EncryptionInformation_IntegrityInformation_RootSignature {
    return new EncryptionInformation_IntegrityInformation_RootSignature().fromJsonString(jsonString, options);
  }

  static equals(a: EncryptionInformation_IntegrityInformation_RootSignature | PlainMessage<EncryptionInformation_IntegrityInformation_RootSignature> | undefined, b: EncryptionInformation_IntegrityInformation_RootSignature | PlainMessage<EncryptionInformation_IntegrityInformation_RootSignature> | undefined): boolean {
    return proto3.util.equals(EncryptionInformation_IntegrityInformation_RootSignature, a, b);
  }
}

/**
 * @generated from message EncryptionInformation.IntegrityInformation.Segment
 */
export class EncryptionInformation_IntegrityInformation_Segment extends Message<EncryptionInformation_IntegrityInformation_Segment> {
  /**
   * @generated from field: string hash = 1;
   */
  hash = "";

  /**
   * @generated from field: int32 segment_size = 2;
   */
  segmentSize = 0;

  /**
   * @generated from field: int32 encrypted_segment_size = 3;
   */
  encryptedSegmentSize = 0;

  constructor(data?: PartialMessage<EncryptionInformation_IntegrityInformation_Segment>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "EncryptionInformation.IntegrityInformation.Segment";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "segment_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "encrypted_segment_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EncryptionInformation_IntegrityInformation_Segment {
    return new EncryptionInformation_IntegrityInformation_Segment().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EncryptionInformation_IntegrityInformation_Segment {
    return new EncryptionInformation_IntegrityInformation_Segment().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EncryptionInformation_IntegrityInformation_Segment {
    return new EncryptionInformation_IntegrityInformation_Segment().fromJsonString(jsonString, options);
  }

  static equals(a: EncryptionInformation_IntegrityInformation_Segment | PlainMessage<EncryptionInformation_IntegrityInformation_Segment> | undefined, b: EncryptionInformation_IntegrityInformation_Segment | PlainMessage<EncryptionInformation_IntegrityInformation_Segment> | undefined): boolean {
    return proto3.util.equals(EncryptionInformation_IntegrityInformation_Segment, a, b);
  }
}

/**
 * @generated from message ZtdfPolicy
 */
export class ZtdfPolicy extends Message<ZtdfPolicy> {
  /**
   * @generated from field: string uuid = 1;
   */
  uuid = "";

  /**
   * @generated from field: ZtdfPolicy.Body body = 2;
   */
  body?: ZtdfPolicy_Body;

  /**
   * @generated from field: string tdf_spec_version = 3;
   */
  tdfSpecVersion = "";

  constructor(data?: PartialMessage<ZtdfPolicy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ZtdfPolicy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "body", kind: "message", T: ZtdfPolicy_Body },
    { no: 3, name: "tdf_spec_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ZtdfPolicy {
    return new ZtdfPolicy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ZtdfPolicy {
    return new ZtdfPolicy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ZtdfPolicy {
    return new ZtdfPolicy().fromJsonString(jsonString, options);
  }

  static equals(a: ZtdfPolicy | PlainMessage<ZtdfPolicy> | undefined, b: ZtdfPolicy | PlainMessage<ZtdfPolicy> | undefined): boolean {
    return proto3.util.equals(ZtdfPolicy, a, b);
  }
}

/**
 * @generated from message ZtdfPolicy.Body
 */
export class ZtdfPolicy_Body extends Message<ZtdfPolicy_Body> {
  /**
   * @generated from field: repeated ZtdfPolicy.Body.Attribute data_attributes = 1;
   */
  dataAttributes: ZtdfPolicy_Body_Attribute[] = [];

  /**
   * @generated from field: repeated string dissem = 2;
   */
  dissem: string[] = [];

  constructor(data?: PartialMessage<ZtdfPolicy_Body>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ZtdfPolicy.Body";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data_attributes", kind: "message", T: ZtdfPolicy_Body_Attribute, repeated: true },
    { no: 2, name: "dissem", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ZtdfPolicy_Body {
    return new ZtdfPolicy_Body().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ZtdfPolicy_Body {
    return new ZtdfPolicy_Body().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ZtdfPolicy_Body {
    return new ZtdfPolicy_Body().fromJsonString(jsonString, options);
  }

  static equals(a: ZtdfPolicy_Body | PlainMessage<ZtdfPolicy_Body> | undefined, b: ZtdfPolicy_Body | PlainMessage<ZtdfPolicy_Body> | undefined): boolean {
    return proto3.util.equals(ZtdfPolicy_Body, a, b);
  }
}

/**
 * @generated from message ZtdfPolicy.Body.Attribute
 */
export class ZtdfPolicy_Body_Attribute extends Message<ZtdfPolicy_Body_Attribute> {
  /**
   * @generated from field: string attribute = 1;
   */
  attribute = "";

  /**
   * @generated from field: string display_name = 2;
   */
  displayName = "";

  /**
   * @generated from field: bool is_default = 3;
   */
  isDefault = false;

  /**
   * @generated from field: string pub_key = 4;
   */
  pubKey = "";

  /**
   * @generated from field: string kas_URL = 5;
   */
  kasURL = "";

  constructor(data?: PartialMessage<ZtdfPolicy_Body_Attribute>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ZtdfPolicy.Body.Attribute";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "attribute", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "display_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "is_default", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "pub_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "kas_URL", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ZtdfPolicy_Body_Attribute {
    return new ZtdfPolicy_Body_Attribute().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ZtdfPolicy_Body_Attribute {
    return new ZtdfPolicy_Body_Attribute().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ZtdfPolicy_Body_Attribute {
    return new ZtdfPolicy_Body_Attribute().fromJsonString(jsonString, options);
  }

  static equals(a: ZtdfPolicy_Body_Attribute | PlainMessage<ZtdfPolicy_Body_Attribute> | undefined, b: ZtdfPolicy_Body_Attribute | PlainMessage<ZtdfPolicy_Body_Attribute> | undefined): boolean {
    return proto3.util.equals(ZtdfPolicy_Body_Attribute, a, b);
  }
}

/**
 * @generated from message ZtdfPolicy.Body.Attribute.AttributeDefinition
 */
export class ZtdfPolicy_Body_Attribute_AttributeDefinition extends Message<ZtdfPolicy_Body_Attribute_AttributeDefinition> {
  /**
   * @generated from field: ZtdfPolicy.Body.Attribute.AttributeDefinition.AttributeRuleType rule_type = 1;
   */
  ruleType = ZtdfPolicy_Body_Attribute_AttributeDefinition_AttributeRuleType.ANY_OF;

  /**
   * @generated from field: repeated string valid_values = 2;
   */
  validValues: string[] = [];

  constructor(data?: PartialMessage<ZtdfPolicy_Body_Attribute_AttributeDefinition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ZtdfPolicy.Body.Attribute.AttributeDefinition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rule_type", kind: "enum", T: proto3.getEnumType(ZtdfPolicy_Body_Attribute_AttributeDefinition_AttributeRuleType) },
    { no: 2, name: "valid_values", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ZtdfPolicy_Body_Attribute_AttributeDefinition {
    return new ZtdfPolicy_Body_Attribute_AttributeDefinition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ZtdfPolicy_Body_Attribute_AttributeDefinition {
    return new ZtdfPolicy_Body_Attribute_AttributeDefinition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ZtdfPolicy_Body_Attribute_AttributeDefinition {
    return new ZtdfPolicy_Body_Attribute_AttributeDefinition().fromJsonString(jsonString, options);
  }

  static equals(a: ZtdfPolicy_Body_Attribute_AttributeDefinition | PlainMessage<ZtdfPolicy_Body_Attribute_AttributeDefinition> | undefined, b: ZtdfPolicy_Body_Attribute_AttributeDefinition | PlainMessage<ZtdfPolicy_Body_Attribute_AttributeDefinition> | undefined): boolean {
    return proto3.util.equals(ZtdfPolicy_Body_Attribute_AttributeDefinition, a, b);
  }
}

/**
 * @generated from enum ZtdfPolicy.Body.Attribute.AttributeDefinition.AttributeRuleType
 */
export enum ZtdfPolicy_Body_Attribute_AttributeDefinition_AttributeRuleType {
  /**
   * @generated from enum value: ANY_OF = 0;
   */
  ANY_OF = 0,

  /**
   * @generated from enum value: ALL_OF = 1;
   */
  ALL_OF = 1,

  /**
   * @generated from enum value: HIERARCHY = 2;
   */
  HIERARCHY = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ZtdfPolicy_Body_Attribute_AttributeDefinition_AttributeRuleType)
proto3.util.setEnumType(ZtdfPolicy_Body_Attribute_AttributeDefinition_AttributeRuleType, "ZtdfPolicy.Body.Attribute.AttributeDefinition.AttributeRuleType", [
  { no: 0, name: "ANY_OF" },
  { no: 1, name: "ALL_OF" },
  { no: 2, name: "HIERARCHY" },
]);

/**
 * @generated from message PayloadReference
 */
export class PayloadReference extends Message<PayloadReference> {
  /**
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * @generated from field: string url = 2;
   */
  url = "";

  /**
   * @generated from field: string protocol = 3;
   */
  protocol = "";

  /**
   * @generated from field: bool is_encrypted = 4;
   */
  isEncrypted = false;

  /**
   * @generated from field: string mime_type = 5;
   */
  mimeType = "";

  /**
   * @generated from field: string tdf_spec_version = 6;
   */
  tdfSpecVersion = "";

  constructor(data?: PartialMessage<PayloadReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "PayloadReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "protocol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "is_encrypted", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "mime_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "tdf_spec_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PayloadReference {
    return new PayloadReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PayloadReference {
    return new PayloadReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PayloadReference {
    return new PayloadReference().fromJsonString(jsonString, options);
  }

  static equals(a: PayloadReference | PlainMessage<PayloadReference> | undefined, b: PayloadReference | PlainMessage<PayloadReference> | undefined): boolean {
    return proto3.util.equals(PayloadReference, a, b);
  }
}

/**
 * @generated from message Manifest
 */
export class Manifest extends Message<Manifest> {
  /**
   * @generated from field: repeated Assertion assertions = 1;
   */
  assertions: Assertion[] = [];

  /**
   * @generated from field: EncryptionInformation encryption_information = 2;
   */
  encryptionInformation?: EncryptionInformation;

  /**
   * @generated from field: PayloadReference payload = 3;
   */
  payload?: PayloadReference;

  constructor(data?: PartialMessage<Manifest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Manifest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "assertions", kind: "message", T: Assertion, repeated: true },
    { no: 2, name: "encryption_information", kind: "message", T: EncryptionInformation },
    { no: 3, name: "payload", kind: "message", T: PayloadReference },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Manifest {
    return new Manifest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Manifest {
    return new Manifest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Manifest {
    return new Manifest().fromJsonString(jsonString, options);
  }

  static equals(a: Manifest | PlainMessage<Manifest> | undefined, b: Manifest | PlainMessage<Manifest> | undefined): boolean {
    return proto3.util.equals(Manifest, a, b);
  }
}

/**
 * @generated from message Payload
 */
export class Payload extends Message<Payload> {
  /**
   * @generated from field: bytes data = 1;
   */
  data = new Uint8Array(0);

  constructor(data?: PartialMessage<Payload>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Payload";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Payload {
    return new Payload().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Payload {
    return new Payload().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Payload {
    return new Payload().fromJsonString(jsonString, options);
  }

  static equals(a: Payload | PlainMessage<Payload> | undefined, b: Payload | PlainMessage<Payload> | undefined): boolean {
    return proto3.util.equals(Payload, a, b);
  }
}

/**
 * @generated from message TrustedDataObject
 */
export class TrustedDataObject extends Message<TrustedDataObject> {
  /**
   * @generated from field: Manifest manifest = 1;
   */
  manifest?: Manifest;

  /**
   * @generated from field: Payload payload = 2;
   */
  payload?: Payload;

  constructor(data?: PartialMessage<TrustedDataObject>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "TrustedDataObject";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "manifest", kind: "message", T: Manifest },
    { no: 2, name: "payload", kind: "message", T: Payload },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TrustedDataObject {
    return new TrustedDataObject().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TrustedDataObject {
    return new TrustedDataObject().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TrustedDataObject {
    return new TrustedDataObject().fromJsonString(jsonString, options);
  }

  static equals(a: TrustedDataObject | PlainMessage<TrustedDataObject> | undefined, b: TrustedDataObject | PlainMessage<TrustedDataObject> | undefined): boolean {
    return proto3.util.equals(TrustedDataObject, a, b);
  }
}

