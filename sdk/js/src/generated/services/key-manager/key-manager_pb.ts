// @generated by protoc-gen-es v1.10.1 with parameter "target=ts"
// @generated from file services/key-manager/key-manager.proto (package key_manager, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";

/**
 * Key Provider Types
 *
 * @generated from enum key_manager.KeyProviderType
 */
export enum KeyProviderType {
  /**
   * @generated from enum value: KEY_PROVIDER_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: KEY_PROVIDER_TYPE_SOFTWARE = 1;
   */
  SOFTWARE = 1,

  /**
   * @generated from enum value: KEY_PROVIDER_TYPE_HSM = 2;
   */
  HSM = 2,

  /**
   * @generated from enum value: KEY_PROVIDER_TYPE_SMART_CARD = 3;
   */
  SMART_CARD = 3,

  /**
   * @generated from enum value: KEY_PROVIDER_TYPE_USB_TOKEN = 4;
   */
  USB_TOKEN = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(KeyProviderType)
proto3.util.setEnumType(KeyProviderType, "key_manager.KeyProviderType", [
  { no: 0, name: "KEY_PROVIDER_TYPE_UNSPECIFIED" },
  { no: 1, name: "KEY_PROVIDER_TYPE_SOFTWARE" },
  { no: 2, name: "KEY_PROVIDER_TYPE_HSM" },
  { no: 3, name: "KEY_PROVIDER_TYPE_SMART_CARD" },
  { no: 4, name: "KEY_PROVIDER_TYPE_USB_TOKEN" },
]);

/**
 * Key Types
 *
 * @generated from enum key_manager.KeyType
 */
export enum KeyType {
  /**
   * @generated from enum value: KEY_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: KEY_TYPE_RSA_2048 = 1;
   */
  RSA_2048 = 1,

  /**
   * @generated from enum value: KEY_TYPE_RSA_3072 = 2;
   */
  RSA_3072 = 2,

  /**
   * @generated from enum value: KEY_TYPE_RSA_4096 = 3;
   */
  RSA_4096 = 3,

  /**
   * @generated from enum value: KEY_TYPE_ECC_P256 = 4;
   */
  ECC_P256 = 4,

  /**
   * @generated from enum value: KEY_TYPE_ECC_P384 = 5;
   */
  ECC_P384 = 5,

  /**
   * @generated from enum value: KEY_TYPE_ECC_P521 = 6;
   */
  ECC_P521 = 6,

  /**
   * @generated from enum value: KEY_TYPE_KYBER_512 = 7;
   */
  KYBER_512 = 7,

  /**
   * @generated from enum value: KEY_TYPE_KYBER_768 = 8;
   */
  KYBER_768 = 8,

  /**
   * @generated from enum value: KEY_TYPE_KYBER_1024 = 9;
   */
  KYBER_1024 = 9,
}
// Retrieve enum metadata with: proto3.getEnumType(KeyType)
proto3.util.setEnumType(KeyType, "key_manager.KeyType", [
  { no: 0, name: "KEY_TYPE_UNSPECIFIED" },
  { no: 1, name: "KEY_TYPE_RSA_2048" },
  { no: 2, name: "KEY_TYPE_RSA_3072" },
  { no: 3, name: "KEY_TYPE_RSA_4096" },
  { no: 4, name: "KEY_TYPE_ECC_P256" },
  { no: 5, name: "KEY_TYPE_ECC_P384" },
  { no: 6, name: "KEY_TYPE_ECC_P521" },
  { no: 7, name: "KEY_TYPE_KYBER_512" },
  { no: 8, name: "KEY_TYPE_KYBER_768" },
  { no: 9, name: "KEY_TYPE_KYBER_1024" },
]);

/**
 * Key Status
 *
 * @generated from enum key_manager.KeyStatus
 */
export enum KeyStatus {
  /**
   * @generated from enum value: KEY_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: KEY_STATUS_ACTIVE = 1;
   */
  ACTIVE = 1,

  /**
   * @generated from enum value: KEY_STATUS_INACTIVE = 2;
   */
  INACTIVE = 2,

  /**
   * @generated from enum value: KEY_STATUS_PENDING_ROTATION = 3;
   */
  PENDING_ROTATION = 3,

  /**
   * @generated from enum value: KEY_STATUS_DEPRECATED = 4;
   */
  DEPRECATED = 4,

  /**
   * @generated from enum value: KEY_STATUS_COMPROMISED = 5;
   */
  COMPROMISED = 5,

  /**
   * @generated from enum value: KEY_STATUS_REVOKED = 6;
   */
  REVOKED = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(KeyStatus)
proto3.util.setEnumType(KeyStatus, "key_manager.KeyStatus", [
  { no: 0, name: "KEY_STATUS_UNSPECIFIED" },
  { no: 1, name: "KEY_STATUS_ACTIVE" },
  { no: 2, name: "KEY_STATUS_INACTIVE" },
  { no: 3, name: "KEY_STATUS_PENDING_ROTATION" },
  { no: 4, name: "KEY_STATUS_DEPRECATED" },
  { no: 5, name: "KEY_STATUS_COMPROMISED" },
  { no: 6, name: "KEY_STATUS_REVOKED" },
]);

/**
 * Key Rotation Policy
 *
 * @generated from enum key_manager.RotationPolicy
 */
export enum RotationPolicy {
  /**
   * @generated from enum value: ROTATION_POLICY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: ROTATION_POLICY_MANUAL = 1;
   */
  MANUAL = 1,

  /**
   * @generated from enum value: ROTATION_POLICY_TIME_BASED = 2;
   */
  TIME_BASED = 2,

  /**
   * @generated from enum value: ROTATION_POLICY_USAGE_BASED = 3;
   */
  USAGE_BASED = 3,

  /**
   * @generated from enum value: ROTATION_POLICY_COMBINED = 4;
   */
  COMBINED = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(RotationPolicy)
proto3.util.setEnumType(RotationPolicy, "key_manager.RotationPolicy", [
  { no: 0, name: "ROTATION_POLICY_UNSPECIFIED" },
  { no: 1, name: "ROTATION_POLICY_MANUAL" },
  { no: 2, name: "ROTATION_POLICY_TIME_BASED" },
  { no: 3, name: "ROTATION_POLICY_USAGE_BASED" },
  { no: 4, name: "ROTATION_POLICY_COMBINED" },
]);

/**
 * Key metadata and information
 *
 * @generated from message key_manager.Key
 */
export class Key extends Message<Key> {
  /**
   * @generated from field: string key_id = 1;
   */
  keyId = "";

  /**
   * @generated from field: string client_id = 2;
   */
  clientId = "";

  /**
   * @generated from field: string name = 3;
   */
  name = "";

  /**
   * @generated from field: key_manager.KeyType key_type = 4;
   */
  keyType = KeyType.UNSPECIFIED;

  /**
   * @generated from field: key_manager.KeyProviderType provider_type = 5;
   */
  providerType = KeyProviderType.UNSPECIFIED;

  /**
   * @generated from field: key_manager.KeyStatus status = 6;
   */
  status = KeyStatus.UNSPECIFIED;

  /**
   * @generated from field: string public_key_pem = 7;
   */
  publicKeyPem = "";

  /**
   * @generated from field: google.protobuf.Timestamp created_at = 8;
   */
  createdAt?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp expires_at = 9;
   */
  expiresAt?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp last_rotated = 10;
   */
  lastRotated?: Timestamp;

  /**
   * @generated from field: string key_integrity_hash = 11;
   */
  keyIntegrityHash = "";

  /**
   * @generated from field: key_manager.RotationPolicy rotation_policy = 12;
   */
  rotationPolicy = RotationPolicy.UNSPECIFIED;

  /**
   * @generated from field: int32 rotation_interval_days = 13;
   */
  rotationIntervalDays = 0;

  /**
   * @generated from field: int64 usage_count = 14;
   */
  usageCount = protoInt64.zero;

  /**
   * @generated from field: int64 max_usage_count = 15;
   */
  maxUsageCount = protoInt64.zero;

  /**
   * @generated from field: map<string, string> metadata = 16;
   */
  metadata: { [key: string]: string } = {};

  constructor(data?: PartialMessage<Key>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.Key";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "client_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "key_type", kind: "enum", T: proto3.getEnumType(KeyType) },
    { no: 5, name: "provider_type", kind: "enum", T: proto3.getEnumType(KeyProviderType) },
    { no: 6, name: "status", kind: "enum", T: proto3.getEnumType(KeyStatus) },
    { no: 7, name: "public_key_pem", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "created_at", kind: "message", T: Timestamp },
    { no: 9, name: "expires_at", kind: "message", T: Timestamp },
    { no: 10, name: "last_rotated", kind: "message", T: Timestamp },
    { no: 11, name: "key_integrity_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "rotation_policy", kind: "enum", T: proto3.getEnumType(RotationPolicy) },
    { no: 13, name: "rotation_interval_days", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 14, name: "usage_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 15, name: "max_usage_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 16, name: "metadata", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Key {
    return new Key().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Key {
    return new Key().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Key {
    return new Key().fromJsonString(jsonString, options);
  }

  static equals(a: Key | PlainMessage<Key> | undefined, b: Key | PlainMessage<Key> | undefined): boolean {
    return proto3.util.equals(Key, a, b);
  }
}

/**
 * Key Provider Information
 *
 * @generated from message key_manager.KeyProvider
 */
export class KeyProvider extends Message<KeyProvider> {
  /**
   * @generated from field: key_manager.KeyProviderType type = 1;
   */
  type = KeyProviderType.UNSPECIFIED;

  /**
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * @generated from field: bool available = 4;
   */
  available = false;

  /**
   * @generated from field: map<string, string> configuration = 5;
   */
  configuration: { [key: string]: string } = {};

  /**
   * @generated from field: repeated key_manager.KeyType supported_key_types = 6;
   */
  supportedKeyTypes: KeyType[] = [];

  /**
   * @generated from field: bool supports_rotation = 7;
   */
  supportsRotation = false;

  /**
   * @generated from field: bool supports_hardware_security = 8;
   */
  supportsHardwareSecurity = false;

  constructor(data?: PartialMessage<KeyProvider>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.KeyProvider";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(KeyProviderType) },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "available", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "configuration", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 6, name: "supported_key_types", kind: "enum", T: proto3.getEnumType(KeyType), repeated: true },
    { no: 7, name: "supports_rotation", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "supports_hardware_security", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KeyProvider {
    return new KeyProvider().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KeyProvider {
    return new KeyProvider().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KeyProvider {
    return new KeyProvider().fromJsonString(jsonString, options);
  }

  static equals(a: KeyProvider | PlainMessage<KeyProvider> | undefined, b: KeyProvider | PlainMessage<KeyProvider> | undefined): boolean {
    return proto3.util.equals(KeyProvider, a, b);
  }
}

/**
 * ABAC Rule for key access control
 *
 * @generated from message key_manager.ABACRule
 */
export class ABACRule extends Message<ABACRule> {
  /**
   * @generated from field: string rule_id = 1;
   */
  ruleId = "";

  /**
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * @generated from field: repeated string required_attributes = 3;
   */
  requiredAttributes: string[] = [];

  /**
   * @generated from field: repeated key_manager.Condition conditions = 4;
   */
  conditions: Condition[] = [];

  /**
   * @generated from field: repeated string allowed_actions = 5;
   */
  allowedActions: string[] = [];

  /**
   * @generated from field: bool enabled = 6;
   */
  enabled = false;

  constructor(data?: PartialMessage<ABACRule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.ABACRule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rule_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "required_attributes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "conditions", kind: "message", T: Condition, repeated: true },
    { no: 5, name: "allowed_actions", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ABACRule {
    return new ABACRule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ABACRule {
    return new ABACRule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ABACRule {
    return new ABACRule().fromJsonString(jsonString, options);
  }

  static equals(a: ABACRule | PlainMessage<ABACRule> | undefined, b: ABACRule | PlainMessage<ABACRule> | undefined): boolean {
    return proto3.util.equals(ABACRule, a, b);
  }
}

/**
 * Condition for ABAC evaluation
 *
 * @generated from message key_manager.Condition
 */
export class Condition extends Message<Condition> {
  /**
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * @generated from field: string operator = 2;
   */
  operator = "";

  /**
   * @generated from field: string value = 3;
   */
  value = "";

  /**
   * @generated from field: map<string, string> parameters = 4;
   */
  parameters: { [key: string]: string } = {};

  constructor(data?: PartialMessage<Condition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.Condition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "operator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "parameters", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Condition {
    return new Condition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Condition {
    return new Condition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Condition {
    return new Condition().fromJsonString(jsonString, options);
  }

  static equals(a: Condition | PlainMessage<Condition> | undefined, b: Condition | PlainMessage<Condition> | undefined): boolean {
    return proto3.util.equals(Condition, a, b);
  }
}

/**
 * Create Key Request
 *
 * @generated from message key_manager.CreateKeyRequest
 */
export class CreateKeyRequest extends Message<CreateKeyRequest> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: key_manager.KeyType key_type = 2;
   */
  keyType = KeyType.UNSPECIFIED;

  /**
   * @generated from field: key_manager.KeyProviderType provider_type = 3;
   */
  providerType = KeyProviderType.UNSPECIFIED;

  /**
   * @generated from field: key_manager.RotationPolicy rotation_policy = 4;
   */
  rotationPolicy = RotationPolicy.UNSPECIFIED;

  /**
   * @generated from field: int32 rotation_interval_days = 5;
   */
  rotationIntervalDays = 0;

  /**
   * @generated from field: int64 max_usage_count = 6;
   */
  maxUsageCount = protoInt64.zero;

  /**
   * @generated from field: google.protobuf.Timestamp expires_at = 7;
   */
  expiresAt?: Timestamp;

  /**
   * @generated from field: map<string, string> metadata = 8;
   */
  metadata: { [key: string]: string } = {};

  /**
   * @generated from field: repeated string authorized_subjects = 9;
   */
  authorizedSubjects: string[] = [];

  /**
   * @generated from field: repeated string authorized_resources = 10;
   */
  authorizedResources: string[] = [];

  /**
   * @generated from field: map<string, string> provider_config = 11;
   */
  providerConfig: { [key: string]: string } = {};

  constructor(data?: PartialMessage<CreateKeyRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.CreateKeyRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "key_type", kind: "enum", T: proto3.getEnumType(KeyType) },
    { no: 3, name: "provider_type", kind: "enum", T: proto3.getEnumType(KeyProviderType) },
    { no: 4, name: "rotation_policy", kind: "enum", T: proto3.getEnumType(RotationPolicy) },
    { no: 5, name: "rotation_interval_days", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "max_usage_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "expires_at", kind: "message", T: Timestamp },
    { no: 8, name: "metadata", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 9, name: "authorized_subjects", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 10, name: "authorized_resources", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 11, name: "provider_config", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateKeyRequest {
    return new CreateKeyRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateKeyRequest {
    return new CreateKeyRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateKeyRequest {
    return new CreateKeyRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateKeyRequest | PlainMessage<CreateKeyRequest> | undefined, b: CreateKeyRequest | PlainMessage<CreateKeyRequest> | undefined): boolean {
    return proto3.util.equals(CreateKeyRequest, a, b);
  }
}

/**
 * Create Key Response
 *
 * @generated from message key_manager.CreateKeyResponse
 */
export class CreateKeyResponse extends Message<CreateKeyResponse> {
  /**
   * @generated from field: key_manager.Key key = 1;
   */
  key?: Key;

  /**
   * @generated from field: google.protobuf.Timestamp timestamp = 2;
   */
  timestamp?: Timestamp;

  constructor(data?: PartialMessage<CreateKeyResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.CreateKeyResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "message", T: Key },
    { no: 2, name: "timestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateKeyResponse {
    return new CreateKeyResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateKeyResponse {
    return new CreateKeyResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateKeyResponse {
    return new CreateKeyResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateKeyResponse | PlainMessage<CreateKeyResponse> | undefined, b: CreateKeyResponse | PlainMessage<CreateKeyResponse> | undefined): boolean {
    return proto3.util.equals(CreateKeyResponse, a, b);
  }
}

/**
 * Get Key Request
 *
 * @generated from message key_manager.GetKeyRequest
 */
export class GetKeyRequest extends Message<GetKeyRequest> {
  /**
   * @generated from field: string key_id = 1;
   */
  keyId = "";

  /**
   * @generated from field: bool include_public_key = 2;
   */
  includePublicKey = false;

  constructor(data?: PartialMessage<GetKeyRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.GetKeyRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "include_public_key", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetKeyRequest {
    return new GetKeyRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetKeyRequest {
    return new GetKeyRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetKeyRequest {
    return new GetKeyRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetKeyRequest | PlainMessage<GetKeyRequest> | undefined, b: GetKeyRequest | PlainMessage<GetKeyRequest> | undefined): boolean {
    return proto3.util.equals(GetKeyRequest, a, b);
  }
}

/**
 * Get Key Response
 *
 * @generated from message key_manager.GetKeyResponse
 */
export class GetKeyResponse extends Message<GetKeyResponse> {
  /**
   * @generated from field: key_manager.Key key = 1;
   */
  key?: Key;

  /**
   * @generated from field: google.protobuf.Timestamp timestamp = 2;
   */
  timestamp?: Timestamp;

  constructor(data?: PartialMessage<GetKeyResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.GetKeyResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "message", T: Key },
    { no: 2, name: "timestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetKeyResponse {
    return new GetKeyResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetKeyResponse {
    return new GetKeyResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetKeyResponse {
    return new GetKeyResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetKeyResponse | PlainMessage<GetKeyResponse> | undefined, b: GetKeyResponse | PlainMessage<GetKeyResponse> | undefined): boolean {
    return proto3.util.equals(GetKeyResponse, a, b);
  }
}

/**
 * List Keys Request
 *
 * @generated from message key_manager.ListKeysRequest
 */
export class ListKeysRequest extends Message<ListKeysRequest> {
  /**
   * @generated from field: string subject_filter = 1;
   */
  subjectFilter = "";

  /**
   * @generated from field: string resource_filter = 2;
   */
  resourceFilter = "";

  /**
   * @generated from field: key_manager.KeyProviderType provider_type_filter = 3;
   */
  providerTypeFilter = KeyProviderType.UNSPECIFIED;

  /**
   * @generated from field: key_manager.KeyStatus status_filter = 4;
   */
  statusFilter = KeyStatus.UNSPECIFIED;

  /**
   * @generated from field: int32 page_size = 5;
   */
  pageSize = 0;

  /**
   * @generated from field: string page_token = 6;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListKeysRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.ListKeysRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subject_filter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "resource_filter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "provider_type_filter", kind: "enum", T: proto3.getEnumType(KeyProviderType) },
    { no: 4, name: "status_filter", kind: "enum", T: proto3.getEnumType(KeyStatus) },
    { no: 5, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListKeysRequest {
    return new ListKeysRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListKeysRequest {
    return new ListKeysRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListKeysRequest {
    return new ListKeysRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListKeysRequest | PlainMessage<ListKeysRequest> | undefined, b: ListKeysRequest | PlainMessage<ListKeysRequest> | undefined): boolean {
    return proto3.util.equals(ListKeysRequest, a, b);
  }
}

/**
 * List Keys Response
 *
 * @generated from message key_manager.ListKeysResponse
 */
export class ListKeysResponse extends Message<ListKeysResponse> {
  /**
   * @generated from field: repeated key_manager.Key keys = 1;
   */
  keys: Key[] = [];

  /**
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  /**
   * @generated from field: int64 total_count = 3;
   */
  totalCount = protoInt64.zero;

  /**
   * @generated from field: google.protobuf.Timestamp timestamp = 4;
   */
  timestamp?: Timestamp;

  constructor(data?: PartialMessage<ListKeysResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.ListKeysResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "keys", kind: "message", T: Key, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "total_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "timestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListKeysResponse {
    return new ListKeysResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListKeysResponse {
    return new ListKeysResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListKeysResponse {
    return new ListKeysResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListKeysResponse | PlainMessage<ListKeysResponse> | undefined, b: ListKeysResponse | PlainMessage<ListKeysResponse> | undefined): boolean {
    return proto3.util.equals(ListKeysResponse, a, b);
  }
}

/**
 * Delete Key Request
 *
 * @generated from message key_manager.DeleteKeyRequest
 */
export class DeleteKeyRequest extends Message<DeleteKeyRequest> {
  /**
   * @generated from field: string key_id = 1;
   */
  keyId = "";

  /**
   * @generated from field: bool force = 2;
   */
  force = false;

  constructor(data?: PartialMessage<DeleteKeyRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.DeleteKeyRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "force", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteKeyRequest {
    return new DeleteKeyRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteKeyRequest {
    return new DeleteKeyRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteKeyRequest {
    return new DeleteKeyRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteKeyRequest | PlainMessage<DeleteKeyRequest> | undefined, b: DeleteKeyRequest | PlainMessage<DeleteKeyRequest> | undefined): boolean {
    return proto3.util.equals(DeleteKeyRequest, a, b);
  }
}

/**
 * Delete Key Response
 *
 * @generated from message key_manager.DeleteKeyResponse
 */
export class DeleteKeyResponse extends Message<DeleteKeyResponse> {
  /**
   * @generated from field: bool success = 1;
   */
  success = false;

  /**
   * @generated from field: string message = 2;
   */
  message = "";

  /**
   * @generated from field: google.protobuf.Timestamp timestamp = 3;
   */
  timestamp?: Timestamp;

  constructor(data?: PartialMessage<DeleteKeyResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.DeleteKeyResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "timestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteKeyResponse {
    return new DeleteKeyResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteKeyResponse {
    return new DeleteKeyResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteKeyResponse {
    return new DeleteKeyResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteKeyResponse | PlainMessage<DeleteKeyResponse> | undefined, b: DeleteKeyResponse | PlainMessage<DeleteKeyResponse> | undefined): boolean {
    return proto3.util.equals(DeleteKeyResponse, a, b);
  }
}

/**
 * Rotate Key Request
 *
 * @generated from message key_manager.RotateKeyRequest
 */
export class RotateKeyRequest extends Message<RotateKeyRequest> {
  /**
   * @generated from field: string key_id = 1;
   */
  keyId = "";

  /**
   * @generated from field: bool force = 2;
   */
  force = false;

  /**
   * @generated from field: google.protobuf.Timestamp effective_at = 3;
   */
  effectiveAt?: Timestamp;

  constructor(data?: PartialMessage<RotateKeyRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.RotateKeyRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "force", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "effective_at", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RotateKeyRequest {
    return new RotateKeyRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RotateKeyRequest {
    return new RotateKeyRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RotateKeyRequest {
    return new RotateKeyRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RotateKeyRequest | PlainMessage<RotateKeyRequest> | undefined, b: RotateKeyRequest | PlainMessage<RotateKeyRequest> | undefined): boolean {
    return proto3.util.equals(RotateKeyRequest, a, b);
  }
}

/**
 * Rotate Key Response
 *
 * @generated from message key_manager.RotateKeyResponse
 */
export class RotateKeyResponse extends Message<RotateKeyResponse> {
  /**
   * @generated from field: key_manager.Key old_key = 1;
   */
  oldKey?: Key;

  /**
   * @generated from field: key_manager.Key new_key = 2;
   */
  newKey?: Key;

  /**
   * @generated from field: google.protobuf.Timestamp timestamp = 3;
   */
  timestamp?: Timestamp;

  constructor(data?: PartialMessage<RotateKeyResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.RotateKeyResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "old_key", kind: "message", T: Key },
    { no: 2, name: "new_key", kind: "message", T: Key },
    { no: 3, name: "timestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RotateKeyResponse {
    return new RotateKeyResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RotateKeyResponse {
    return new RotateKeyResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RotateKeyResponse {
    return new RotateKeyResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RotateKeyResponse | PlainMessage<RotateKeyResponse> | undefined, b: RotateKeyResponse | PlainMessage<RotateKeyResponse> | undefined): boolean {
    return proto3.util.equals(RotateKeyResponse, a, b);
  }
}

/**
 * Unwrap DEK Request
 *
 * @generated from message key_manager.UnwrapDEKRequest
 */
export class UnwrapDEKRequest extends Message<UnwrapDEKRequest> {
  /**
   * @generated from field: string subject = 1;
   */
  subject = "";

  /**
   * @generated from field: string resource = 2;
   */
  resource = "";

  /**
   * @generated from field: bytes encrypted_dek = 3;
   */
  encryptedDek = new Uint8Array(0);

  /**
   * @generated from field: string key_id = 4;
   */
  keyId = "";

  /**
   * @generated from field: string client_key_id = 5;
   */
  clientKeyId = "";

  /**
   * @generated from field: map<string, string> context = 6;
   */
  context: { [key: string]: string } = {};

  /**
   * @generated from field: string action = 7;
   */
  action = "";

  constructor(data?: PartialMessage<UnwrapDEKRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.UnwrapDEKRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subject", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "resource", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "encrypted_dek", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "key_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "client_key_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "context", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 7, name: "action", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnwrapDEKRequest {
    return new UnwrapDEKRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnwrapDEKRequest {
    return new UnwrapDEKRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnwrapDEKRequest {
    return new UnwrapDEKRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UnwrapDEKRequest | PlainMessage<UnwrapDEKRequest> | undefined, b: UnwrapDEKRequest | PlainMessage<UnwrapDEKRequest> | undefined): boolean {
    return proto3.util.equals(UnwrapDEKRequest, a, b);
  }
}

/**
 * Unwrap DEK Response
 *
 * @generated from message key_manager.UnwrapDEKResponse
 */
export class UnwrapDEKResponse extends Message<UnwrapDEKResponse> {
  /**
   * @generated from field: bytes encrypted_dek_for_subject = 1;
   */
  encryptedDekForSubject = new Uint8Array(0);

  /**
   * @generated from field: string subject_key_id = 2;
   */
  subjectKeyId = "";

  /**
   * @generated from field: bool access_granted = 3;
   */
  accessGranted = false;

  /**
   * @generated from field: string access_reason = 4;
   */
  accessReason = "";

  /**
   * @generated from field: repeated string applied_rules = 5;
   */
  appliedRules: string[] = [];

  /**
   * @generated from field: google.protobuf.Timestamp timestamp = 6;
   */
  timestamp?: Timestamp;

  constructor(data?: PartialMessage<UnwrapDEKResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.UnwrapDEKResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encrypted_dek_for_subject", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "subject_key_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "access_granted", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "access_reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "applied_rules", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "timestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnwrapDEKResponse {
    return new UnwrapDEKResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnwrapDEKResponse {
    return new UnwrapDEKResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnwrapDEKResponse {
    return new UnwrapDEKResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UnwrapDEKResponse | PlainMessage<UnwrapDEKResponse> | undefined, b: UnwrapDEKResponse | PlainMessage<UnwrapDEKResponse> | undefined): boolean {
    return proto3.util.equals(UnwrapDEKResponse, a, b);
  }
}

/**
 * List Providers Request
 *
 * @generated from message key_manager.ListProvidersRequest
 */
export class ListProvidersRequest extends Message<ListProvidersRequest> {
  /**
   * @generated from field: bool available_only = 1;
   */
  availableOnly = false;

  constructor(data?: PartialMessage<ListProvidersRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.ListProvidersRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "available_only", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListProvidersRequest {
    return new ListProvidersRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListProvidersRequest {
    return new ListProvidersRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListProvidersRequest {
    return new ListProvidersRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListProvidersRequest | PlainMessage<ListProvidersRequest> | undefined, b: ListProvidersRequest | PlainMessage<ListProvidersRequest> | undefined): boolean {
    return proto3.util.equals(ListProvidersRequest, a, b);
  }
}

/**
 * List Providers Response
 *
 * @generated from message key_manager.ListProvidersResponse
 */
export class ListProvidersResponse extends Message<ListProvidersResponse> {
  /**
   * @generated from field: repeated key_manager.KeyProvider providers = 1;
   */
  providers: KeyProvider[] = [];

  /**
   * @generated from field: google.protobuf.Timestamp timestamp = 2;
   */
  timestamp?: Timestamp;

  constructor(data?: PartialMessage<ListProvidersResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.ListProvidersResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "providers", kind: "message", T: KeyProvider, repeated: true },
    { no: 2, name: "timestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListProvidersResponse {
    return new ListProvidersResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListProvidersResponse {
    return new ListProvidersResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListProvidersResponse {
    return new ListProvidersResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListProvidersResponse | PlainMessage<ListProvidersResponse> | undefined, b: ListProvidersResponse | PlainMessage<ListProvidersResponse> | undefined): boolean {
    return proto3.util.equals(ListProvidersResponse, a, b);
  }
}

/**
 * Get Provider Info Request
 *
 * @generated from message key_manager.GetProviderInfoRequest
 */
export class GetProviderInfoRequest extends Message<GetProviderInfoRequest> {
  /**
   * @generated from field: key_manager.KeyProviderType provider_type = 1;
   */
  providerType = KeyProviderType.UNSPECIFIED;

  constructor(data?: PartialMessage<GetProviderInfoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.GetProviderInfoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "provider_type", kind: "enum", T: proto3.getEnumType(KeyProviderType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetProviderInfoRequest {
    return new GetProviderInfoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetProviderInfoRequest {
    return new GetProviderInfoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetProviderInfoRequest {
    return new GetProviderInfoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetProviderInfoRequest | PlainMessage<GetProviderInfoRequest> | undefined, b: GetProviderInfoRequest | PlainMessage<GetProviderInfoRequest> | undefined): boolean {
    return proto3.util.equals(GetProviderInfoRequest, a, b);
  }
}

/**
 * Get Provider Info Response
 *
 * @generated from message key_manager.GetProviderInfoResponse
 */
export class GetProviderInfoResponse extends Message<GetProviderInfoResponse> {
  /**
   * @generated from field: key_manager.KeyProvider provider = 1;
   */
  provider?: KeyProvider;

  /**
   * @generated from field: google.protobuf.Timestamp timestamp = 2;
   */
  timestamp?: Timestamp;

  constructor(data?: PartialMessage<GetProviderInfoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.GetProviderInfoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "provider", kind: "message", T: KeyProvider },
    { no: 2, name: "timestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetProviderInfoResponse {
    return new GetProviderInfoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetProviderInfoResponse {
    return new GetProviderInfoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetProviderInfoResponse {
    return new GetProviderInfoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetProviderInfoResponse | PlainMessage<GetProviderInfoResponse> | undefined, b: GetProviderInfoResponse | PlainMessage<GetProviderInfoResponse> | undefined): boolean {
    return proto3.util.equals(GetProviderInfoResponse, a, b);
  }
}

/**
 * RegisterClientKeyRequest represents a request to register a public key
 *
 * @generated from message key_manager.RegisterClientKeyRequest
 */
export class RegisterClientKeyRequest extends Message<RegisterClientKeyRequest> {
  /**
   * The client name
   *
   * @generated from field: string client_id = 1;
   */
  clientId = "";

  /**
   * The public key in PEM format
   *
   * @generated from field: string public_key_pem = 2;
   */
  publicKeyPem = "";

  /**
   * Type of the key
   *
   * @generated from field: key_manager.KeyType key_type = 3;
   */
  keyType = KeyType.UNSPECIFIED;

  /**
   * When the key should expire (optional)
   *
   * @generated from field: google.protobuf.Timestamp expires_at = 4;
   */
  expiresAt?: Timestamp;

  /**
   * Key metadata
   *
   * @generated from field: map<string, string> metadata = 5;
   */
  metadata: { [key: string]: string } = {};

  constructor(data?: PartialMessage<RegisterClientKeyRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.RegisterClientKeyRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "client_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "public_key_pem", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "key_type", kind: "enum", T: proto3.getEnumType(KeyType) },
    { no: 4, name: "expires_at", kind: "message", T: Timestamp },
    { no: 5, name: "metadata", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegisterClientKeyRequest {
    return new RegisterClientKeyRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegisterClientKeyRequest {
    return new RegisterClientKeyRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegisterClientKeyRequest {
    return new RegisterClientKeyRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RegisterClientKeyRequest | PlainMessage<RegisterClientKeyRequest> | undefined, b: RegisterClientKeyRequest | PlainMessage<RegisterClientKeyRequest> | undefined): boolean {
    return proto3.util.equals(RegisterClientKeyRequest, a, b);
  }
}

/**
 * RegisterClientKeyResponse represents the response from registering a key
 *
 * @generated from message key_manager.RegisterClientKeyResponse
 */
export class RegisterClientKeyResponse extends Message<RegisterClientKeyResponse> {
  /**
   * The registered key information
   *
   * @generated from field: key_manager.Key key = 1;
   */
  key?: Key;

  /**
   * Success indicator
   *
   * @generated from field: bool success = 2;
   */
  success = false;

  /**
   * Error message if registration failed
   *
   * @generated from field: string error_message = 3;
   */
  errorMessage = "";

  /**
   * Timestamp of the operation
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 4;
   */
  timestamp?: Timestamp;

  constructor(data?: PartialMessage<RegisterClientKeyResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.RegisterClientKeyResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "message", T: Key },
    { no: 2, name: "success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "error_message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "timestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegisterClientKeyResponse {
    return new RegisterClientKeyResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegisterClientKeyResponse {
    return new RegisterClientKeyResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegisterClientKeyResponse {
    return new RegisterClientKeyResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RegisterClientKeyResponse | PlainMessage<RegisterClientKeyResponse> | undefined, b: RegisterClientKeyResponse | PlainMessage<RegisterClientKeyResponse> | undefined): boolean {
    return proto3.util.equals(RegisterClientKeyResponse, a, b);
  }
}

/**
 * GetClientKeyRequest represents a request to get a specific user key
 *
 * @generated from message key_manager.GetClientKeyRequest
 */
export class GetClientKeyRequest extends Message<GetClientKeyRequest> {
  /**
   * The client name
   *
   * @generated from field: string client_id = 1;
   */
  clientId = "";

  /**
   * The key ID to retrieve (optional, gets active key if not specified)
   *
   * @generated from field: string key_id = 2;
   */
  keyId = "";

  constructor(data?: PartialMessage<GetClientKeyRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.GetClientKeyRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "client_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "key_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetClientKeyRequest {
    return new GetClientKeyRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetClientKeyRequest {
    return new GetClientKeyRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetClientKeyRequest {
    return new GetClientKeyRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetClientKeyRequest | PlainMessage<GetClientKeyRequest> | undefined, b: GetClientKeyRequest | PlainMessage<GetClientKeyRequest> | undefined): boolean {
    return proto3.util.equals(GetClientKeyRequest, a, b);
  }
}

/**
 * GetClientKeyResponse represents the response from getting a user key
 *
 * @generated from message key_manager.GetClientKeyResponse
 */
export class GetClientKeyResponse extends Message<GetClientKeyResponse> {
  /**
   * The requested key
   *
   * @generated from field: key_manager.Key key = 1;
   */
  key?: Key;

  /**
   * Whether the key was found
   *
   * @generated from field: bool found = 2;
   */
  found = false;

  /**
   * Error message if retrieval failed
   *
   * @generated from field: string error_message = 3;
   */
  errorMessage = "";

  /**
   * Timestamp of the operation
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 4;
   */
  timestamp?: Timestamp;

  constructor(data?: PartialMessage<GetClientKeyResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.GetClientKeyResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "message", T: Key },
    { no: 2, name: "found", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "error_message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "timestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetClientKeyResponse {
    return new GetClientKeyResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetClientKeyResponse {
    return new GetClientKeyResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetClientKeyResponse {
    return new GetClientKeyResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetClientKeyResponse | PlainMessage<GetClientKeyResponse> | undefined, b: GetClientKeyResponse | PlainMessage<GetClientKeyResponse> | undefined): boolean {
    return proto3.util.equals(GetClientKeyResponse, a, b);
  }
}

/**
 * ListClientKeysRequest represents a request to list clients's keys
 *
 * @generated from message key_manager.ListClientKeysRequest
 */
export class ListClientKeysRequest extends Message<ListClientKeysRequest> {
  /**
   * The client name
   *
   * @generated from field: string client_id = 1;
   */
  clientId = "";

  /**
   * Page size for pagination
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize = 0;

  /**
   * Page token for pagination
   *
   * @generated from field: string page_token = 3;
   */
  pageToken = "";

  /**
   * Include revoked keys
   *
   * @generated from field: bool include_revoked = 4;
   */
  includeRevoked = false;

  constructor(data?: PartialMessage<ListClientKeysRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.ListClientKeysRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "client_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "include_revoked", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListClientKeysRequest {
    return new ListClientKeysRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListClientKeysRequest {
    return new ListClientKeysRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListClientKeysRequest {
    return new ListClientKeysRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListClientKeysRequest | PlainMessage<ListClientKeysRequest> | undefined, b: ListClientKeysRequest | PlainMessage<ListClientKeysRequest> | undefined): boolean {
    return proto3.util.equals(ListClientKeysRequest, a, b);
  }
}

/**
 * ListClientKeysResponse represents the response from listing user's keys
 *
 * @generated from message key_manager.ListClientKeysResponse
 */
export class ListClientKeysResponse extends Message<ListClientKeysResponse> {
  /**
   * List of keys
   *
   * @generated from field: repeated key_manager.Key keys = 1;
   */
  keys: Key[] = [];

  /**
   * Next page token
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  /**
   * Total count of keys
   *
   * @generated from field: int32 total_count = 3;
   */
  totalCount = 0;

  /**
   * Timestamp of the operation
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 4;
   */
  timestamp?: Timestamp;

  constructor(data?: PartialMessage<ListClientKeysResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.ListClientKeysResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "keys", kind: "message", T: Key, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "total_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "timestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListClientKeysResponse {
    return new ListClientKeysResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListClientKeysResponse {
    return new ListClientKeysResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListClientKeysResponse {
    return new ListClientKeysResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListClientKeysResponse | PlainMessage<ListClientKeysResponse> | undefined, b: ListClientKeysResponse | PlainMessage<ListClientKeysResponse> | undefined): boolean {
    return proto3.util.equals(ListClientKeysResponse, a, b);
  }
}

/**
 * RevokeClientKeyRequest represents a request to revoke a user key
 *
 * @generated from message key_manager.RevokeClientKeyRequest
 */
export class RevokeClientKeyRequest extends Message<RevokeClientKeyRequest> {
  /**
   * The client name
   *
   * @generated from field: string client_id = 1;
   */
  clientId = "";

  /**
   * The key ID to revoke
   *
   * @generated from field: string key_id = 2;
   */
  keyId = "";

  /**
   * Reason for revocation
   *
   * @generated from field: string reason = 3;
   */
  reason = "";

  constructor(data?: PartialMessage<RevokeClientKeyRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.RevokeClientKeyRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "client_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "key_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RevokeClientKeyRequest {
    return new RevokeClientKeyRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RevokeClientKeyRequest {
    return new RevokeClientKeyRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RevokeClientKeyRequest {
    return new RevokeClientKeyRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RevokeClientKeyRequest | PlainMessage<RevokeClientKeyRequest> | undefined, b: RevokeClientKeyRequest | PlainMessage<RevokeClientKeyRequest> | undefined): boolean {
    return proto3.util.equals(RevokeClientKeyRequest, a, b);
  }
}

/**
 * RevokeClientKeyResponse represents the response from revoking a key
 *
 * @generated from message key_manager.RevokeClientKeyResponse
 */
export class RevokeClientKeyResponse extends Message<RevokeClientKeyResponse> {
  /**
   * Success indicator
   *
   * @generated from field: bool success = 1;
   */
  success = false;

  /**
   * Error message if revocation failed
   *
   * @generated from field: string error_message = 2;
   */
  errorMessage = "";

  /**
   * Timestamp of the operation
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 3;
   */
  timestamp?: Timestamp;

  constructor(data?: PartialMessage<RevokeClientKeyResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.RevokeClientKeyResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "error_message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "timestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RevokeClientKeyResponse {
    return new RevokeClientKeyResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RevokeClientKeyResponse {
    return new RevokeClientKeyResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RevokeClientKeyResponse {
    return new RevokeClientKeyResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RevokeClientKeyResponse | PlainMessage<RevokeClientKeyResponse> | undefined, b: RevokeClientKeyResponse | PlainMessage<RevokeClientKeyResponse> | undefined): boolean {
    return proto3.util.equals(RevokeClientKeyResponse, a, b);
  }
}

/**
 * ListClientsRequest represents a request to list all clients (admin operation)
 *
 * @generated from message key_manager.ListClientsRequest
 */
export class ListClientsRequest extends Message<ListClientsRequest> {
  /**
   * Page size for pagination
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize = 0;

  /**
   * Page token for pagination
   *
   * @generated from field: string page_token = 2;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListClientsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.ListClientsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListClientsRequest {
    return new ListClientsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListClientsRequest {
    return new ListClientsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListClientsRequest {
    return new ListClientsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListClientsRequest | PlainMessage<ListClientsRequest> | undefined, b: ListClientsRequest | PlainMessage<ListClientsRequest> | undefined): boolean {
    return proto3.util.equals(ListClientsRequest, a, b);
  }
}

/**
 * ListClientsResponse represents the response from listing clients
 *
 * @generated from message key_manager.ListClientsResponse
 */
export class ListClientsResponse extends Message<ListClientsResponse> {
  /**
   * List of client IDs
   *
   * @generated from field: repeated string clients = 1;
   */
  clients: string[] = [];

  /**
   * Next page token
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  /**
   * Total count of clients
   *
   * @generated from field: int32 total_count = 3;
   */
  totalCount = 0;

  /**
   * Timestamp of the operation
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 4;
   */
  timestamp?: Timestamp;

  constructor(data?: PartialMessage<ListClientsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "key_manager.ListClientsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "clients", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "total_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "timestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListClientsResponse {
    return new ListClientsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListClientsResponse {
    return new ListClientsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListClientsResponse {
    return new ListClientsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListClientsResponse | PlainMessage<ListClientsResponse> | undefined, b: ListClientsResponse | PlainMessage<ListClientsResponse> | undefined): boolean {
    return proto3.util.equals(ListClientsResponse, a, b);
  }
}

